/* This file downloaded from Highend3d.com
''  
''  Highend3d.com File Information:
''  
''    Script Name: duplicateParticleInstanceFinal
''    Author:  
''    Last Updated: Mar 02, 2008
''    Update/Change this file at:
''    http://Highend3d.com/maya/downloads/mel_scripts/dynamics/4752.html
''  
''  Please do not alter any information above this line
''  it is generated dynamically by Highend3d.com and will
''  be changed automatically on any updates.
*/
global string $parInsGrp,$grpTemp;proc float[] strConMatrix(string $matrix){string $buffer[];float $buffer2[];tokenize $matrix  $buffer;	for ($i=0;$i<size($buffer);$i++)	{	$buffer2[$i]=float($buffer[$i]);	}return $buffer2;}proc vector worldToLoc(vector $worldVector,string $matrixStr){float $matrix[]=`strConMatrix $matrixStr`;float $pointX=($worldVector.x)*$matrix[0]+($worldVector.y)*$matrix[4]+($worldVector.z)*$matrix[8];float $pointY=($worldVector.x)*$matrix[1]+($worldVector.y)*$matrix[5]+($worldVector.z)*$matrix[9];float $pointZ=($worldVector.x)*$matrix[2]+($worldVector.y)*$matrix[6]+($worldVector.z)*$matrix[10];vector $point=<<$pointX,$pointY,$pointZ>>;return $point;}proc string rotationTypeDup(string $objName,vector $objScale,vector $objShear,vector $objWPos,vector $objRot,int $objVis,string $matrix,int $index){global string $grpTemp;xform -a -ws -t ($objWPos.x) ($objWPos.y) ($objWPos.z) -s ($objScale.x) ($objScale.y) ($objScale.z) -sh ($objShear.x) ($objShear.y) ($objShear.z) -ro ($objRot.x) ($objRot.y) ($objRot.z) $grpTemp;string $dupObjName="duplicate_"+$index+"_"+$objName;duplicate  -n $dupObjName -rr $objName;xform -ws -t 0 0 0 $dupObjName;setAttr ($dupObjName+".visibility") $objVis;parent -r $dupObjName $grpTemp;parent -w -a $dupObjName;xform -a -ws -t 0 0 0 -s 1 1 1 -sh 0 0 0 -ro 0 0 0 $grpTemp;return ($dupObjName);}proc string aimDirDup(string $objName,vector $objScale,vector $objShear,vector $objWPos,vector $objAimDir,vector $objAimAxis,vector $objAimUp,vector $objAimWUp,string $matrix,int $objVis,int $index){global string $parInsGrp,$grpTemp;string $dupObjName="duplicate_"+$index+"_"+$objName;duplicate  -n $dupObjName -rr $objName;xform -ws -t 0 0 0 $dupObjName;setAttr ($dupObjName+".visibility") $objVis;xform -a -ws -t 0 0 0 -s ($objScale.x) ($objScale.y) ($objScale.z) -sh ($objShear.x) ($objShear.y) ($objShear.z) $grpTemp;xform -a -ws -t ($objAimDir.x) ($objAimDir.y) ($objAimDir.z) $parInsGrp;$objAimAxis=`worldToLoc $objAimAxis $matrix`;$objAimUp=`worldToLoc $objAimUp $matrix`;aimConstraint -offset 0 0 0 -weight 1 -aimVector ($objAimAxis.x) ($objAimAxis.y) ($objAimAxis.z) -upVector ($objAimUp.x) ($objAimUp.y) ($objAimUp.z) -worldUpType "vector" -worldUpVector ($objAimWUp.x) ($objAimWUp.y) ($objAimWUp.z) $parInsGrp $grpTemp;aimConstraint -e -rm $parInsGrp $grpTemp;xform -a -ws -t ($objWPos.x) ($objWPos.y) ($objWPos.z) $grpTemp;parent -r $dupObjName $grpTemp;parent -w -a $dupObjName;xform -a -ws -t 0 0 0 -s 1 1 1 -sh 0 0 0 -ro 0 0 0 $grpTemp;return ($dupObjName);}proc string aimPosDup(string $objName,vector $objScale,vector $objShear,vector $objWPos,vector $objAimPos,vector $objAimAxis,vector $objAimUp,vector $objAimWUp,string $matrix,int $objVis, int $index){global string $parInsGrp,$grpTemp;string $dupObjName="duplicate_"+$index+"_"+$objName;duplicate  -n $dupObjName -rr $objName;xform -ws -t 0 0 0 $dupObjName;setAttr ($dupObjName+".visibility") $objVis;xform -a -ws -s ($objScale.x) ($objScale.y) ($objScale.z) -sh ($objShear.x) ($objShear.y) ($objShear.z) -t ($objWPos.x) ($objWPos.y) ($objWPos.z) $grpTemp;xform -a -ws -t ($objAimPos.x) ($objAimPos.y) ($objAimPos.z) $parInsGrp;$objAimAxis=`worldToLoc $objAimAxis $matrix`;$objAimUp=`worldToLoc $objAimUp $matrix`;aimConstraint -offset 0 0 0 -weight 1 -aimVector ($objAimAxis.x) ($objAimAxis.y) ($objAimAxis.z) -upVector ($objAimUp.x) ($objAimUp.y) ($objAimUp.z) -worldUpType "vector" -worldUpVector ($objAimWUp.x) ($objAimWUp.y) ($objAimWUp.z) $parInsGrp $grpTemp;aimConstraint -e -rm $parInsGrp $grpTemp;parent -r $dupObjName $grpTemp;parent -w -a $dupObjName;xform -a -ws -t 0 0 0 -s 1 1 1 -sh 0 0 0 -ro 0 0 0 $grpTemp;return ($dupObjName);}proc string defaultDup(string $objName, vector $objScale,vector $objShear,vector $objWPos,vector $objRot,int $objVis,string $matrix,int $index){global string $grpTemp;string $dupObjName="duplicate_"+$index+"_"+$objName;duplicate  -n $dupObjName -rr $objName;xform -a -ws -s ($objScale.x) ($objScale.y) ($objScale.z) -ro ($objRot.x) ($objRot.y) ($objRot.z)  -sh ($objShear.x) ($objShear.y) ($objShear.z)  -t ($objWPos.x) ($objWPos.y) ($objWPos.z)  $grpTemp;setAttr ($dupObjName+".visibility") $objVis;parent -r $dupObjName $grpTemp;float $matrixNum[]=`strConMatrix $matrix`;xform -m  $matrixNum[0] $matrixNum[1] $matrixNum[2] $matrixNum[3] $matrixNum[4] $matrixNum[5] $matrixNum[6] $matrixNum[7] $matrixNum[8] $matrixNum[9] $matrixNum[10] $matrixNum[11] $matrixNum[12] $matrixNum[13] $matrixNum[14] $matrixNum[15] $dupObjName;parent -w -a $dupObjName;xform -a -ws -t 0 0 0 -s 1 1 1 -sh 0 0 0 -ro 0 0 0 $grpTemp;return ($dupObjName);}proc  particleiInsDup(){global string $parInsGrp,$grpTemp;string $positionAttr,$objectIndexAttr,$scaleAttr,$shearAttr,$rotationTypeAttr,$rotationAttr,$aimDirectionAttr,$aimPositionAttr,$aimAxisAttr,$aimUpAxisAttr,$aimWorldUpAttr,$visibilityAttr;//translateAttr variablestring $matrixStore[];//storeAttr variable//vector $rotPivot,$scalePivot;string $pSName[]=`ls -dag -s -sl`;if (`attributeExists "count" $pSName[0]`){int $pCount=`getAttr ($pSName[0]+".count")`;string $insSName[]=`listConnections -d 1 -s 0 -type "instancer" ($pSName[0])`;string $objectInsName[]=`listConnections -d 0 -s 1  ($insSName[0]+".inputHierarchy")`;int $rotAngUnt=`getAttr ($insSName[0]+".rotationAngleUnits")`;//query instancer rotationAngleUnits is degrees(0) or Radians(1)string $attrMap[]=`particleInstancer -name $insSName[0] -q -am $pSName[0]`;for ($i=0;$i<size($attrMap);$i++)	{	switch ($attrMap[$i])		{		case "position":			$positionAttr=$attrMap[($i+1)];			$i++;			break;		case "objectIndex":			$objectIndexAttr=$attrMap[($i+1)];			$i++;			break;		case "scale":			$scaleAttr=$attrMap[($i+1)];			$i++;			break;		case "shear":			$shearAttr=$attrMap[($i+1)];			$i++;			break;		case "rotationType"://RotationType attribute, use a value of 0 for Rotation, 1 for AimDirection, or 2 for AimPosition.			$rotationTypeAttr=$attrMap[($i+1)];			$i++;			break;		case "rotation":			$rotationAttr=$attrMap[($i+1)];			$i++;			break;		case "aimDirection":			$aimDirectionAttr=$attrMap[($i+1)];			$i++;			break;		case "aimPosition":			$aimPositionAttr=$attrMap[($i+1)];			$i++;			break;		case "aimAxis":			$aimAxisAttr=$attrMap[($i+1)];			$i++;			break;		case "aimUpAxis":			$aimUpAxisAttr=$attrMap[($i+1)];			$i++;			break;		case "aimWorldUp":			$aimWorldUpAttr=$attrMap[($i+1)];			$i++;			break;		case "visibility":			$visibilityAttr=$attrMap[($i+1)];			$i++;			break;		}	}for ($i=0;$i<size($objectInsName);$i++)	{	float $matrixTemp[]=`getAttr ($objectInsName[$i]+".matrix")`;	$matrixStore[$i]=$matrixTemp[0]+" "+$matrixTemp[1]+" "+$matrixTemp[2]+" "+$matrixTemp[3]+" "+$matrixTemp[4]+" "+$matrixTemp[5]+" "+$matrixTemp[6]+" "+$matrixTemp[7]+" "+$matrixTemp[8]+" "+$matrixTemp[9]+" "+$matrixTemp[10]+" "+$matrixTemp[11]+" "+0+" "+0+" "+0+" "+$matrixTemp[15];	}///////getAttr over;$parInsGrp=`group -em -n "parInsGrpTemp"`;string $locName[]=`spaceLocator -p 0 0 0`;$grpTemp=$locName[0];if (`objExists ($insSName[0]+"DuplicateGroup")`) delete ($insSName[0]+"DuplicateGroup");string $groupName=`group -em -n ($insSName[0]+"DuplicateGroup")`;string $duplicateName;int $rotationType;if ($rotationAttr!="")	$rotationType=0;else 	{	if ($aimDirectionAttr!="")		$rotationType=1;	else		{		if ($aimPositionAttr!="")			$rotationType=2;		else $rotationType=3;		}	}for ($i=0;$i<$pCount;$i++)	{ 	int $objVis,$index;	vector $objScale,$objShear,$objWPos;//////	if ($rotationTypeAttr!="")		{		$rotationTypeTmp=`particle -attribute $rotationTypeAttr -or $i -q $pSName[0]`;			if ((int($rotationTypeTmp[0])<3)&&(int($rotationTypeTmp[0])>=0))		$rotationType=int($rotationTypeTmp[0]);			else 		$rotationType=0;		}	if ($objectIndexAttr!="")		{		$indexTemp=`particle -attribute $objectIndexAttr -or $i -q $pSName[0]`;		$index=int($indexTemp[0]);		if ($index<0) $index=0;		if ($index>=size($objectInsName)) $index=size($objectInsName)-1;		}	else 		$index=0;	string $objName=$objectInsName[$index];	if ($scaleAttr!="")		{		$objScale=`particle -attribute $scaleAttr -or $i -q $pSName[0]`;		}	else 		$objScale=<<1,1,1>>;	if ($shearAttr!="")		{		$objShear=`particle -attribute $shearAttr -or $i -q $pSName[0]`;		}	else		$objShear=<<0,0,0>>;	if ($positionAttr!="")		$objWPos=`particle -attribute $positionAttr -or $i -q $pSName[0]`;	else 		$objWPos=<<0,0,0>>;	if ($visibilityAttr!="")		{		$objVisTemp=`particle -attribute $visibilityAttr -or $i -q $pSName[0]`;		$objVis=int($objVisTemp[0]);		if ($objVis<=0) $objVis=0;		if ($objVis>=1) $objVis=1;		}	else 		$objVis=1;	switch ($rotationType)		{		case 0://rotation,no need objAimAxis,objAimUp,objAimWUp;			vector $objRot;			if ($rotationAttr!="")			{			if ($rotAngUnt==1)				{				vector $objRotTemp=`particle -attribute $rotationAttr -or $i -q $pSName[0]`;				$objRot=<<rad_to_deg($objRotTemp.x),rad_to_deg($objRotTemp.y),rad_to_deg($objRotTemp.z)>>;				}			else $objRot=`particle -attribute $rotationAttr -or $i -q $pSName[0]`;			}			else $objRot=<<0,0,0>>;			$duplicateName=`rotationTypeDup $objName $objScale $objShear $objWPos $objRot $objVis $matrixStore[$index] $i`;			break;		case 1://AimDirection,need objAimAxis,objAimUp,objAimWUp;rotationUnt is ignore ==radius			vector $objAimDir,$objAimAxis,$objAimUp,$objAimWUp,$objAimDirTemp;			if ($aimDirectionAttr!="")			{			$objAimDirTemp=`particle -attribute $aimDirectionAttr -or $i -q $pSName[0]`;			$objAimDir=unit($objAimDirTemp);			}				else   $objAimDir=<<1,0,0>>;			if ($aimAxisAttr!="")				$objAimAxis=`particle -attribute $aimAxisAttr -or $i -q $pSName[0]`;			else				$objAimAxis=<<1,0,0>>;			if ($aimUpAxisAttr!="")				$objAimUp=`particle -attribute $aimUpAxisAttr -or $i -q $pSName[0]`;			else 			$objAimUp=<<0,1,0>>;			if ($aimWorldUpAttr!="")				$objAimWUp=`particle -attribute $aimWorldUpAttr -or $i -q $pSName[0]`;			else				$objAimWUp=<<0,1,0>>;			$duplicateName=`aimDirDup $objName $objScale $objShear $objWPos  $objAimDir $objAimAxis $objAimUp $objAimWUp $matrixStore[$index] $objVis $i`;			break;		case 2://AimPos,need objAimAxis,objAimUp,objAimWUp;			vector $objAimPos,$objAimAxis,$objAimUp,$objAimWUp;			if ($aimPositionAttr!="")				$objAimPos=`particle -attribute $aimPositionAttr -or $i -q $pSName[0]`;			else $objAimPos=<<0,0,0>>;			if ($aimAxisAttr!="")				$objAimAxis=`particle -attribute $aimAxisAttr -or $i -q $pSName[0]`;			else				$objAimAxis=<<1,0,0>>;			if ($aimUpAxisAttr!="")				$objAimUp=`particle -attribute $aimUpAxisAttr -or $i -q $pSName[0]`;			else 				$objAimUp=<<0,1,0>>;			if ($aimWorldUpAttr!="")				$objAimWUp=`particle -attribute $aimWorldUpAttr -or $i -q $pSName[0]`;			else				$objAimWUp=<<0,1,0>>;			$duplicateName=`aimPosDup $objName $objScale $objShear $objWPos $objAimPos $objAimAxis $objAimUp $objAimWUp $matrixStore[$index]  $objVis $i`;			break;		case 3://no rotation`s			$objRot=<<0,0,0>>;			$duplicateName=`defaultDup $objName $objScale $objShear $objWPos $objRot $objVis $matrixStore[$index] $i`;			break;		}	parent $duplicateName $groupName;	}delete $parInsGrp $grpTemp;float $matrix[]=`getAttr ($insSName[0]+".worldMatrix")`;xform -m $matrix[0] $matrix[1] $matrix[2] $matrix[3] $matrix[4] $matrix[5] $matrix[6] $matrix[7] $matrix[8] $matrix[9] $matrix[10] $matrix[11] $matrix[12] $matrix[13] $matrix[14] $matrix[15] $groupName;}else print "=================please select particle node which has a instancer,then do duplicate===============";}particleiInsDup();